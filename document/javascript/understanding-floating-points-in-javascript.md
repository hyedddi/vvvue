# 자바스크립트의 부동 소수점 이해하기

대부분의 프로그래밍 언어는 여러 종류의 숫자형 데이터를 지원하지만 자바스크립트에서는 하나의 숫자형 데이터만 지원한다. 실제로 하나의 숫자형만 지원하는지 확인하기 위해서는 자바스크립트의  `typeof` 연산자를 이용할 수 있다.

```javascript
console.log(typeof 10);   // number
console.log(typeof 10.3); // number
console.log(typeof -10);  // number
```

사실, 자바스크립트 내의 모든 숫자는 `IEEE 754` 표준에서 정의한 64 비트로 인코딩된 배정밀도의(`double-precision`) 부동 소수점으로 흔히 `double`로 알려진 숫자다.

그렇다면 흔히 우리가 알고 있는 `integer` 숫자형의 어떻게 표현되는 것일까?

`double`은 53비트까지의 정확도로 완벽하게 `integer`로 표현할 수 있다. `-9,007,199,254,740,992(-2^53)`부터 `9,007,199,254,740,992(2^53)`까지의 모든 `integer`는 유효한 `double` 값들이다. 따라서 자바스크립트에서 `integer` 연산은 별도의 `integer`형 없이도 완벽하게 가능하다.

대부분의 산술 연산자는 정수형이나 실수 또는 이 둘의 조합으로 동작하게 된다.

```javascript
0.8 * 0.9
-100 + 100
21 - 23.2
1.3 / 2
99 % 10
```

하지만 비트 단위 연산자는 특별한 점이 있다. 인자들을 직접 부동 소수점 숫자처럼 처리하지 않고, 암묵적으로 32비트 정수로 변환한다.(정확하게는 32비트, `big-endian`, 2의 보수로 처리된다.) 예를 들어 비트 단위 `OR` 표현식을 살펴보자.

```markdown
8 | 1; // 9
```

위의 표현식은 사실 몇 가지의 평가 단계를 거치게 된다. 자바스크립트의 숫자 8과 1은 항상 `double` 형이다. 하지만 32비트 정수형, 즉 32개의 0과 1로도 표현될 수 있다. 다음은 숫자 8을 표현한 것이다.

```markdown
000000000000000000000000001000
```

숫자형 객체의 toString 메서드를 사용해서 직접 확인할 수 있다.

```javascript
(8).toString(2); // 1000
```

메서드에 인자로 2를 대입했는데, 여기서 인자는 기수(`radix`)를 나타낸다. 즉, 2진 바이너리로 표현한 것이다. 다음은 숫자 1을 표현한 것이다.

```markdown
000000000000000000000000000001
```

그럼 다시 `OR` 표현식으로 돌아가면 두 비트 시퀀스를 합치게 되고 다음의 결과가 된다.

```javascript
000000000000000000000000001001
```

결과 시퀀스는 정수형 9를 나타낸다. 이를 검증하고 싶다면 parseInt 메서드에 기수를 2로 지정하면 된다.

위에서 본 것과 같이 자바스크립트에서 모든 비트단위 연산자는 동일한 방식으로 동작한다. 입력 값을 정수형으로 변환하고, 정수 비트 패턴에서 각 연산을 수행한 뒤, 표준 자바스크립트 부동 소수점 숫자 값으로 변환해 결과를 반환하다. 이러한 변환들은 자바스크립트 엔진에서 별도의 작업을 필요로 한다. 숫자 값이 부동 소수점으로 저장되기 때문에, 반드시 정수형으로 변환하고 다시 부동 소수점으로 되돌려야한다. 하지만 연산 표현식이나 변수가 명시적으로 정수형으로 동작할 때면, 최적화 컴파일러가 실행되어 데이터를 내부적으로 정수형으로 저장하여 부가적인 변환을 회피하기도 한다.

하지만 명심해야 할 것이 있다. 부동 소수점 숫자는 사고뭉치라는 것이다.

이유는 부동 소수점은 부정확하기 때문이다. 간단한 산술 연산을 살펴보자.

```javascript
0.1 + 0.2;
```

위의 산술 연산은 크게 고민할 필요없이 `0.3`의 결과를 생각할 수 있다. 하지만 사고뭉치는 `0.30000000000000004`의 값을 반환해준다. 어이가 없다.

64비트의 정확도는 충분히 넓은 범위를 포함할 수 있지만, `double`은 실수에 비해 여전히 64비트 만큼의 유한한 숫자 범위만 포함할 수 있다. 부동 소수점 산술 연산은 근사 값만을 만들어낼 수 있고 가장 가까운 표현가능한 실수로 반올림한다. 이러한 부정확도는 계산을 거듭하고 누적될 수록 더욱 더 부정확한 결과를 초래하게 된다.

그렇기 때문에 부동 소수점의 정확도와 성능은 서로 상충관계라고 표현하는 것이다. 만약 구현하는 비즈니스 로직에 정확도가 중요하다면, 이런 부동 소수점 산술 연산에 대해서 반드시 알아두어야 한다.

그렇다면 자바스크립트는 항상 부정확한 값만 내어놓는가? 그렇지는 않다.

바로 가능한 정수 값을 사용하는 것이다. 정수 값은 반올림 없이 표현이 가능하기 때문이다. 즉, `0.1 + 0.2` 를 `(1 + 2) / 10` 과 같이 계산할 수도 있을 것이다. 그리고 정수를 처리할 때 모든 연산이 `-2^53 ~ 2^53` 범위 내에 맞춰진다는 것도 고려해야한다. 하지만 반올림에 대한 오류는 신경쓰지 않아도 된다.

하지만 정수형 범위를 넘어가는 숫자도 있을 것이다. 이럴때는 `BigInt`라는 정수형 데이터 타입을 사용할 수 있다. igInt는 64비트 부동 소수점이 가진 정밀도 제한을 넘는 수를 처리할 수 있다.

```javascript
console.log(9007199254740992);      // 9007199254740992 (정확도 손실)
console.log(9007199254740992n);    // 9007199254740992n (정확도 유지, BigInt)
```

추가적으로 입실론을 사용하는 방법도 있다. 궁금하다면 알아보도록 하자.

## 참고 레퍼런스

- [Bigint](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/BigInt)
- [Javascript Number type](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number)
